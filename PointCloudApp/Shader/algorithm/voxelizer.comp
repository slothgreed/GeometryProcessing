


layout(std430,binding = 0) buffer posBuffer
{
	vec4 position[];
};

layout(std430,binding = 1) buffer indexBuffer
{
	uint indexs[];
};

layout(std430,binding = 2) buffer voxelBuffer
{
	uint voxel[];
};


uniform float u_pitch;
uniform int u_resolute;
uniform vec3 u_min;
uniform int u_triNum;

void main()
{
	uint triIdx = gl_GlobalInvocationID.x;
	if(triIdx >= u_triNum) {return;}
	
	
	vec3 p0 = position[indexs[3 * triIdx + 0]].xyz - u_min;
	vec3 p1 = position[indexs[3 * triIdx + 1]].xyz - u_min;
	vec3 p2 = position[indexs[3 * triIdx + 2]].xyz - u_min;

	vec3 edge0 = p1 - p0;
	vec3 edge1 = p2 - p1;
	vec3 edge2 = p0 - p2;
	
	vec3 normal = normalize(cross(edge0,edge1));
	vec3 c = vec3(0);
	if(normal.x > 0.0){c.x = u_pitch;}
	if(normal.y > 0.0){c.y = u_pitch;}
	if(normal.z > 0.0){c.z = u_pitch;}
	float d1 = dot(normal,(c - p0));
	float d2 = dot(normal,(vec3(u_pitch) - c) - p0);
	vec3 bdbMin_ = min(min(p0,p1),p2);
	vec3 bdbMax_ = max(max(p0,p1),p2);
	ivec3 bdbMin = clamp(ivec3(bdbMin_ / u_pitch), ivec3(0),ivec3(u_resolute - 1));
	ivec3 bdbMax = clamp(ivec3(bdbMax_ / u_pitch), ivec3(0),ivec3(u_resolute - 1));
	vec2 xyEdge[3];
	float xyDiff[3];
	xyEdge[0] = vec2(-edge0.y, edge0.x);
	xyEdge[1] = vec2(-edge1.y, edge1.x);
	xyEdge[2] = vec2(-edge2.y, edge2.x);
	if(normal.z < 0){xyEdge[0] = -xyEdge[0]; xyEdge[1] = -xyEdge[1]; xyEdge[2] = -xyEdge[2];}
	xyDiff[0] = (-dot(xyEdge[0], vec2(p0.x, p0.y))) + max(0.0f, u_pitch * xyEdge[0].x) + max(0.0f, u_pitch * xyEdge[0].y);
	xyDiff[1] = (-dot(xyEdge[1], vec2(p1.x, p1.y))) + max(0.0f, u_pitch * xyEdge[1].x) + max(0.0f, u_pitch * xyEdge[1].y);
	xyDiff[2] = (-dot(xyEdge[2], vec2(p2.x, p2.y))) + max(0.0f, u_pitch * xyEdge[2].x) + max(0.0f, u_pitch * xyEdge[2].y);
	
	vec2 yzEdge[3];
	float yzDiff[3];
	yzEdge[0] = vec2(-edge0.z, edge0.y);
	yzEdge[1] = vec2(-edge1.z, edge1.y);
	yzEdge[2] = vec2(-edge2.z, edge2.y);
	if(normal.x < 0){yzEdge[0] = -yzEdge[0]; yzEdge[1] = -yzEdge[1]; yzEdge[2] = -yzEdge[2];}
	yzDiff[0] = (-dot(yzEdge[0], vec2(p0.y, p0.z))) + max(0.0f, u_pitch * yzEdge[0].x) + max(0.0f, u_pitch * yzEdge[0].y);
	yzDiff[1] = (-dot(yzEdge[1], vec2(p1.y, p1.z))) + max(0.0f, u_pitch * yzEdge[1].x) + max(0.0f, u_pitch * yzEdge[1].y);
	yzDiff[2] = (-dot(yzEdge[2], vec2(p2.y, p2.z))) + max(0.0f, u_pitch * yzEdge[2].x) + max(0.0f, u_pitch * yzEdge[2].y);
	
	vec2 zxEdge[3];
	float zxDiff[3];
	zxEdge[0] = vec2(-edge0.x, edge0.z);
	zxEdge[1] = vec2(-edge1.x, edge1.z);
	zxEdge[2] = vec2(-edge2.x, edge2.z);
	if(normal.y < 0){zxEdge[0] = -zxEdge[0]; zxEdge[1] = -zxEdge[1]; zxEdge[2] = -zxEdge[2];}
	zxDiff[0] = (-dot(zxEdge[0], vec2(p0.z, p0.x))) + max(0.0f, u_pitch * zxEdge[0].x) + max(0.0f, u_pitch * zxEdge[0].y);
	zxDiff[1] = (-dot(zxEdge[1], vec2(p1.z, p1.x))) + max(0.0f, u_pitch * zxEdge[1].x) + max(0.0f, u_pitch * zxEdge[1].y);
	zxDiff[2] = (-dot(zxEdge[2], vec2(p2.z, p2.x))) + max(0.0f, u_pitch * zxEdge[2].x) + max(0.0f, u_pitch * zxEdge[2].y);


	for(int i = bdbMin.x; i <= bdbMax.x; i++){
	for(int j = bdbMin.y; j <= bdbMax.y; j++){
	for(int k = bdbMin.z; k <= bdbMax.z; k++){
		vec3 pos = vec3(i,j,k) * u_pitch;
		float NdotP = dot(normal,pos);
		if(((NdotP + d1) * (NdotP + d2) > 0.0f)){continue;}
		vec2 xyP = vec2(pos.x,pos.y);
		if(dot(xyEdge[0],xyP) + xyDiff[0] < 0.0f){continue;}
		if(dot(xyEdge[1],xyP) + xyDiff[1] < 0.0f){continue;}
		if(dot(xyEdge[2],xyP) + xyDiff[2] < 0.0f){continue;}
		
		vec2 yzP = vec2(pos.y,pos.z);
		if(dot(yzEdge[0],yzP) + yzDiff[0] < 0.0f){continue;}
		if(dot(yzEdge[1],yzP) + yzDiff[1] < 0.0f){continue;}
		if(dot(yzEdge[2],yzP) + yzDiff[2] < 0.0f){continue;}
		
		vec2 zxP = vec2(pos.z,pos.x);
		if(dot(zxEdge[0],zxP) + zxDiff[0] < 0.0f){continue;}
		if(dot(zxEdge[1],zxP) + zxDiff[1] < 0.0f){continue;}
		if(dot(zxEdge[2],zxP) + zxDiff[2] < 0.0f){continue;}

		uint location = i + j * u_resolute + k * u_resolute * u_resolute;
		uint location2 = location / 32;
		uint bit = location % 32;
		uint mask = 1u << bit;
		atomicOr(voxel[location2], mask);

	}}}
} 