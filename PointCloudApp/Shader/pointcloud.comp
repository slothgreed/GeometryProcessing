
layout(std430, binding = 0) buffer colorImageBuffer
{
	uint colorImage[];
};

layout(std430, binding = 1) buffer depthImageBuffer
{
	uint depthImage[];
};

layout(std430, binding = 2) buffer posBuffer
{
	vec4 position[];
};

layout(location = 4) uniform mat4 u_VP;
uniform int u_PositionNum;
uniform ivec2 u_ImageSize;
float packColor(vec3 color) {
    return color.r + color.g * 256.0 + color.b * 256.0 * 256.0;
}

vec4 unpackColor(float f) {
    float fi = round(f);
    vec3 color;
    color.r = floor(fi / 65536.0); // 256 * 256
    fi -= color.r * 65536.0;
    color.g = floor(fi / 256.0);
    fi -= color.g * 256.0;
    color.b = fi;
    return vec4(color / 255.0, 1.0);
}

void main()
{
	uint workGroupSize = 
		gl_WorkGroupSize.x * gl_WorkGroupSize.y;
	uint globalID = 
		gl_WorkGroupID.x * workGroupSize + 
		gl_WorkGroupID.y * gl_NumWorkGroups.x * workGroupSize + 
		gl_LocalInvocationIndex;
	if(globalID > u_PositionNum) {return;}
	vec4 modelPos = position[globalID];
	vec4 pos = u_VP * vec4(modelPos.xyz,1.0);
	pos.xyz = pos.xyz / pos.w;

	if(pos.w <= 0.0 || pos.x < -1.0 || pos.x > 1.0 || pos.y < -1.0 || pos.y > 1.0){
		return;
	}
	
	pos = pos * 0.5 + 0.5;
	ivec2 pixelCoords = ivec2(pos.xy * u_ImageSize);
	uint depth = floatBitsToUint(pos.z);
	uint index = uint(pixelCoords.y * u_ImageSize.x + pixelCoords.x);
#ifdef WRITE_PHASE
	atomicMin(depthImage[index],depth);
#else
	uint imageDepth = depthImage[index];
	if(depth == imageDepth) {
		colorImage[index] = floatBitsToUint(modelPos.w);
	}
#endif
} 