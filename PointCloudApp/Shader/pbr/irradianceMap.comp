
layout(binding = 0) uniform samplerCube u_EnvironmentMap;
layout(binding = 1, rgba32f) writeonly uniform image2DArray irradianceMap;

const float PI = 3.14159265359;

vec3 ConvertCartesian(float sinPhi, float cosPhi, float sinTheta, float cosTheta)
{
	return vec3(
		sinTheta * cosPhi,
		sinTheta * sinPhi,
		cosTheta);
}


void main() {
    ivec3 size = imageSize(irradianceMap);
    vec3 cubeCoord = gl_GlobalInvocationID;
	vec2 texCoord = (vec2(cubeCoord.xy)+0.5) / size.xy;
	texCoord = texCoord * 2.0 - 1.0;
	
	vec3 N;
    if(cubeCoord.z == 0){
        N = vec3(1.0, -texCoord.yx); // posx
	} else if(cubeCoord.z == 1){
        N = vec3(-1.0, -texCoord.y, texCoord.x); //negx
	} else if(cubeCoord.z == 2){
        N = vec3(texCoord.x, 1.0, texCoord.y); // posy
	} else if(cubeCoord.z == 3){
        N = vec3(texCoord.x, -1.0, -texCoord.y); //negy
	} else if(cubeCoord.z == 4){
        N = vec3(texCoord.x, -texCoord.y, 1.0); // posz
	} else if(cubeCoord.z == 5){
        N = vec3(-texCoord.xy, -1.0); // negz
	}
	N = normalize(N);
	
    vec3 up = vec3(0.0, 1.0, 0.0);
    vec3 right = normalize(cross(up, N));
    up = normalize(cross(N, right));

    float sampleDelta = 0.025;
    vec3 irradiance = vec3(0.0);
    float nrSamples = 0.0;

    for (float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta) {
		float cosPhi = cos(phi);
		float sinPhi = sin(phi);
		for (float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta) {
			float cosTheta = cos(theta);
			float sinTheta = sin(theta);
			vec3 tangentSample = ConvertCartesian(sinPhi,cosPhi,sinTheta,cosTheta);
            vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N;
            irradiance += texture(u_EnvironmentMap, sampleVec).rgb * cosTheta * sinTheta;
            nrSamples++;
        }
    }

    irradiance = PI * irradiance * (1.0 / nrSamples);
    imageStore(irradianceMap, ivec3(gl_GlobalInvocationID), vec4(irradiance, 1.0));
}