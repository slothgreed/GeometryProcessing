

layout(triangles) out;

layout(std430, binding = 0) buffer CameraBuffer
{
	Camera camera;
};

layout(std430, binding  = 1) buffer posBuffer
{
	vec4 position[];
};

layout(std430, binding  = 2) buffer meshletBuffer
{
	Meshlet meshlet[];
};

layout(std430, binding  = 3) buffer indexBuffer
{
	int index[];
};

#define MAX_COLORS 10
vec3 meshletcolors[MAX_COLORS] = {
  vec3(1,0,0), 
  vec3(0,1,0),
  vec3(0,0,1),
  vec3(1,1,0),
  vec3(1,0,1),
  vec3(0,1,1),
  vec3(1,0.5,0),
  vec3(0.5,1,0),
  vec3(0,0.5,1),
  vec3(1,1,1)
};

layout (location = 0) out PerVertexData
{
  vec4 color;
} v_out[];

uniform mat4 u_Model;
TaskNV in Task
{
	uint baseID;
	uint drawID[32];
}IN;

void main()
{
	//uint globalID = IN.baseID;
	int laneID = int(gl_LocalInvocationID.x);
	uint globalID = IN.drawID[gl_WorkGroupID.x];
	int vertexOffset = meshlet[globalID].offset;
	int vertexSize = meshlet[globalID].size;
	int meshletIndex = meshlet[globalID].meshletIndex;

	for(int i = laneID; i < vertexSize; i+=int(gl_WorkGroupSize.x))
	{
		gl_MeshVerticesNV[i].gl_Position = camera.VP * u_Model * position[index[vertexOffset + i]];
		gl_PrimitiveIndicesNV[i] = i;
		v_out[i].color =  vec4(meshletcolors[meshletIndex%MAX_COLORS], 1.0);
		//v_out[i].color =  meshlet[meshletIndex].normal;
	}
	if(laneID == 0){
		gl_PrimitiveCountNV = vertexSize / 3;
	}
}